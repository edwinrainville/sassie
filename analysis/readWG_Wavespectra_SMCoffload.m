% matlabt script to read transmitted GPSwaves spectra (csv file)
% generated by Wave Glider onboard processing
% and read into a SWIFT-compliant structure of wave results
%
% J. Thomson, 6/2014
%               3/2017 modified for multiple files, as given by RUDICs sync
%               3/2017 modified to apply dir spread QC in spectra, recalc Tp
%                       and try out check factor corrections
%

clear all, close all

%% QC selection... turn these all off if reprocessing raw data and test new onboard code

% switch to velocity spectral peak
velpeak = false;

% QC metric used to remove eroneous spectral energies at low frequencies
spreadQC = false;
dirspreadcutoff = 60; % 60 works well for dir1, not sure what to use for dir2

% whether or not to apply correction based on spectral check factors (testing)
checkfactorcorrection = false;

% whether of not to apply correction based on antenna height (testing)
antennacorrection = false;
h = 0.65; % antenna height in meters

%% loop thru spectrum files (used to be per mission, now per hour)

fpath = './';

flist = dir([fpath '*spectrum.log']); % sometimes .csv, when supplied by LRI

GPSwaves = [];

for fi = 1:length(flist),
    
    disp(['file ' num2str(fi) ' of ' num2str(length(flist))])
    
    linenum = 0;
    bursts = 1 + length(GPSwaves);
    
    fid = fopen([fpath flist(fi).name ]);
    
    while 1
        
        tline = fgetl(fid);
        
        if tline==-1,
            break,
        end
        
        linenum = linenum + 1;
        linelength = length(tline);
        
        if tline(1:6) == 'PERIOD' & linenum > 1, % this has start and end times, positions, points
            metadata = textscan(tline,'%s%s%s%n%n%n%s%s%n%n%n%n%n%*[^\n]','Delimiter',',');
            GPSwaves(bursts).time = datenum([ char( metadata{2}) ' ' char(metadata{3}) ]);
            GPSwaves(bursts).lat = metadata{5};
            GPSwaves(bursts).lon = metadata{6};
            metalinenum(bursts) = linenum;
            bursts = bursts + 1;
            
            
        elseif tline(1:6) == 'ENERGY', % this line for energy spectra
            GPSwaves(bursts).wavespectra.energy = str2num( tline(14:linelength) )';
        elseif tline(1:4) == 'FREQ', % this line for f
            GPSwaves(bursts).wavespectra.freq = str2num( tline(10:linelength) )';
        elseif tline(1:3) == 'DIR', %this line for directions
            GPSwaves(bursts).wavespectra.dir = str2num( tline(5:linelength) )';
        elseif tline(1:6) == 'SPREAD', % this line for spread
            GPSwaves(bursts).wavespectra.spread = str2num( tline(8:linelength) )';
        elseif tline(1:2) == 'A1', % this line for A1
            GPSwaves(bursts).wavespectra.a1 = str2num( tline(4:linelength) )';
        elseif tline(1:2) == 'B1', % this line for B1
            GPSwaves(bursts).wavespectra.b1 = str2num( tline(4:linelength) )';
        elseif tline(1:2) == 'A2', % this line for A2
            GPSwaves(bursts).wavespectra.a2 = str2num( tline(4:linelength) )';
        elseif tline(1:2) == 'B2', % this line for B2
            GPSwaves(bursts).wavespectra.b2 = str2num( tline(4:linelength) )';
        elseif tline(1:5) == 'CHECK', % go to next line for check
            GPSwaves(bursts).wavespectra.check = str2num( tline(7:linelength) )';
            
        else
        end
        
    end
    fclose(fid);
    
end


%% fill in spectral directional values, if none already reported
bad = [];
for bursts = 1:length(GPSwaves),
    if isempty(GPSwaves(bursts).wavespectra) | isempty(GPSwaves(bursts).time) | length(GPSwaves(bursts).wavespectra.freq) < 2,
        bad(bursts) = bursts;
    elseif ~isfield(GPSwaves(bursts).wavespectra,'dir')
        [Etheta theta f dir spread spread2 spread2alt ] = SWIFTdirectionalspectra(GPSwaves(bursts), 0);
        GPSwaves(bursts).wavespectra.dir = dir;
        GPSwaves(bursts).wavespectra.spread = spread;
    else
    end
end
GPSwaves(find(bad)) = [];


%% make bulk stats, with some QC

badbursts = [];

for bursts = 1:length(GPSwaves),
    
    if ~isempty(GPSwaves(bursts).wavespectra),
        
        % bandwidth
        df = median( abs( diff( GPSwaves(bursts).wavespectra.freq ) ) );
        
        % QC low frequencies (below the velocity peak) based on directional spread
        % then try a direct calc of Tp (as opposed to using velocity spectra)
        % and recalc Tp
        if spreadQC,
            [peake peakind] = max(GPSwaves(bursts).wavespectra.energy.*GPSwaves(bursts).wavespectra.freq.^2);
            bad = GPSwaves(bursts).wavespectra.spread > dirspreadcutoff  &  GPSwaves(bursts).wavespectra.freq < GPSwaves(bursts).wavespectra.freq(peakind) ;
            GPSwaves(bursts).wavespectra.energy( bad ) = NaN;
        else
        end
        
        % optional correction the spectra based on the check factors less than 1
        % (which indicate bias of horizontal motion)
        % and recalc Tp
        if checkfactorcorrection,
            cinds = find( GPSwaves(bursts).wavespectra.check < 1 );
            GPSwaves(bursts).wavespectra.energy(cinds) = GPSwaves(bursts).wavespectra.energy(cinds) .* GPSwaves(bursts).wavespectra.check(cinds).^0.5;
        else
        end
        
        % optional correction for antenna height (see notebook 4/2/2017)
        % based on extra horizontal displacement, with wave slope and small angle approx
        % and recalc Tp
        if antennacorrection,
            mss = GPSwaves(bursts).wavespectra.energy .* (2 * 3.14 * GPSwaves(bursts).wavespectra.freq).^4 ./ (9.8^2);
            antennabias = h.^2  .* mss; % would be sin(srqt(mss)), but assuming small angle
            GPSwaves(bursts).wavespectra.energy = GPSwaves(bursts).wavespectra.energy - antennabias;
        else
        end
        
        % peak wave period (after whatever corrections are applied)
        [peake peakind] = max(GPSwaves(bursts).wavespectra.energy.*GPSwaves(bursts).wavespectra.freq);
        GPSwaves(bursts).peakwaveperiod = 1 ./ GPSwaves(bursts).wavespectra.freq(peakind);
        GPSwaves(bursts).peakwavedirT = GPSwaves(bursts).wavespectra.dir(peakind);
        % option to use freq^2 weighting (equivalent to velocity spectra) to help identify a clear peak
        if velpeak,
            [peake peakind] = max(GPSwaves(bursts).wavespectra.energy.*GPSwaves(bursts).wavespectra.freq.^2);
            GPSwaves(bursts).peakwaveperiod = 1 ./ GPSwaves(bursts).wavespectra.freq(peakind);
            GPSwaves(bursts).peakwavedirT = GPSwaves(bursts).wavespectra.dir(peakind);
        else
        end
        
        % sig wave height
        GPSwaves(bursts).sigwaveheight = 4 * sqrt( nansum( GPSwaves(bursts).wavespectra.energy ) * df ) ;
        
        % plot spectra
%         figure(1)
%         loglog(GPSwaves(bursts).wavespectra.freq, GPSwaves(bursts).wavespectra.energy)
%         hold on
%         xlabel('Frequency [Hz]')
%         ylabel('Energy [m^2/Hz]')
    else
        badbursts(length(badbursts)+1) = bursts;
    end
    
end



%% spectra plot
figure(1),
axis([1e-2 1 1e-3 1e2])
print('-dpng',[fpath 'spectra.png'])



%% calc vehicle speed, assing as "driftspd" in SWIFT compliant structure

dlondt = gradient([GPSwaves.lon],[GPSwaves.time]); % deg per day
dxdt = deg2km(dlondt,6371*cosd(mean([GPSwaves.lat]))) .* 1000 ./ ( 24*3600 ); % m/s
dlatdt = gradient([GPSwaves.lat],[GPSwaves.time]); % deg per day
dydt = deg2km(dlatdt) .* 1000 ./ ( 24*3600 ); % m/s
dxdt(isinf(dxdt)) = NaN;
dydt(isinf(dydt)) = NaN;
vehiclespd = sqrt(dxdt.^2 + dydt.^2); % m/s
vehicledir = -180 ./ 3.14 .* atan2(dydt,dxdt); % cartesian direction [deg]
vehicledir = vehicledir + 90;  % rotate from eastward = 0 to northward  = 0
vehicledir( vehicledir<0) = vehicledir( vehicledir<0 ) + 360; %make quadrant II 270->360 instead of -90->0

for bursts = 1:length(GPSwaves),
    GPSwaves(bursts).driftspd = vehiclespd(bursts);
    GPSwaves(bursts).driftdirT = vehicledir(bursts);
end

%% apply quality control (determined during bulk stats)

GPSwaves(badbursts) = [];

% more quality control... seems to be associated with sample gaps

bad = find([GPSwaves.sigwaveheight] < 0.1);
GPSwaves(bad) = [];
bad = find([GPSwaves.peakwaveperiod] > 18);
GPSwaves(bad) = [];

for gi=1:length(GPSwaves),
    
    % find negative energies (from antenna correction)
    %GPSwaves(gi).wavespectra.energy( GPSwaves(gi).wavespectra.energy < 0 ) = NaN;
    
    % find failed directions
    if GPSwaves(gi).peakwavedirT == 9999;
        GPSwaves(gi).peakwavedirT = NaN;
    else
    end
end


%% save

save([fpath 'GPSwaves.mat'],'GPSwaves')


%% plot timeseeries
figure(10), clf

subplot(3,1,1)
plot([GPSwaves.time],[GPSwaves.sigwaveheight],'k+')
datetick
ylabel('H_s [m]')

subplot(3,1,2)
plot([GPSwaves.time],[GPSwaves.peakwaveperiod],'k+')
datetick
ylabel('T_p [s]')

subplot(3,1,3)
plot([GPSwaves.time],[GPSwaves.peakwavedirT],'k+')
datetick
ylabel('D_p [s]')
set(gca,'YLim',[0 360])

print('-dpng',[fpath 'timeseries.png'])



